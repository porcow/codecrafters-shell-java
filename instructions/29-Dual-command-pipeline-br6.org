In this stage, you'll implement support for basic pipelines involving
two external commands.

A
[[https://www.gnu.org/software/bash/manual/bash.html#Pipelines][pipeline]]
connects the standard output of one command to the standard input of the
next command using the =|= operator.

*** Tests
:PROPERTIES:
:CUSTOM_ID: tests
:END:
The tester will execute your program like this:

#+begin_src sh
./your_program.sh
#+end_src

It'll then execute multiple pipelines with two commands in them.
Examples:

#+begin_src sh
$ cat /tmp/foo/file | wc
       5      10      77
#+end_src

#+begin_src sh
$ tail -f /tmp/foo/file-1 | head -n 5
raspberry strawberry
pear mango
pineapple apple
# (tester appends more lines to /tmp/foo/file-1)
# (And expects the running command to keep printing new lines)
This is line 4.
This is line 5.
$
#+end_src

The tester will check if the final output matches the expected output
after pipeline execution.

For the =tail -f= command, the tester will append content to the the
input file while the pipeline is running.

*** Notes
:PROPERTIES:
:CUSTOM_ID: notes
:END:
- The executables (=cat=, =wc=, =tail=, =head=) will be available in the
  =PATH=.
- To execute a pipeline you'll need to create a
  [[https://en.wikipedia.org/wiki/Anonymous_pipe][pipe]],
  [[https://en.wikipedia.org/wiki/Fork_(system_call)][fork]] processes
  for each command, and set up the standard input/output redirection
  between them.
