In this stage, you'll implement support for quoting with double quotes.

*** Double Quotes
:PROPERTIES:
:CUSTOM_ID: double-quotes
:END:
In shell syntax, most characters within
[[https://www.gnu.org/software/bash/manual/bash.html#Double-Quotes][double quotes]]
(="=) are treated literally. However, double quotes allow certain
special characters to be interpreted (like =$= for variables and =\= for
escaping), but we'll cover those exceptions in later stages.

For this stage, your shell must apply the following rules when parsing
double quotes:

- Consecutive whitespaces (spaces, tabs) must be preserved.
- Characters that normally act as delimiters or special characters lose
  their special meaning inside double quotes and are treated literally.
- Double-quoted strings placed next to each other are concatenated to
  form a single argument.

For example:

#+begin_src sh
$ echo "hello    world"
hello    world         # Multiple spaces preserved

$ echo "hello""world"
helloworld             # Quoted strings next to each other are concatenated.

$ echo "hello" "world"
hello world            # Separate arguments

$ echo "shell's test"
shell's test           # Single quotes inside are literal
#+end_src

*** Tests
:PROPERTIES:
:CUSTOM_ID: tests
:END:
The tester will execute your program like this:

#+begin_src sh
./your_program.sh
#+end_src

It will then send a series of =echo= commands to your shell:

#+begin_src sh
$ echo "quz  hello"  "bar"
quz  hello bar
$ echo "bar"  "shell's"  "foo"
bar shell's foo
$
#+end_src

The tester will check if the =echo= command correctly prints the quoted
text.

Next, the tester will send a =cat= command, with the file name parameter
enclosed in double quotes:

#+begin_src sh
$ cat "/tmp/file name" "/tmp/'file name' with spaces"
content1 content2
#+end_src

The tester will check if the =cat= command correctly prints the file
content.
