In this stage, you'll extend your =cd= builtin to handle relative paths.

*** The =cd= Builtin (Recap)
:PROPERTIES:
:CUSTOM_ID: the-cd-builtin-recap
:END:
As a recap, =cd= can receive multiple argument types:

- Absolute paths, like =/usr/local/bin=. (Handled in previous stages)
- Relative paths, like =./=, =../=, =./dir=.
- The =~= character.

For this stage, you'll handle the second argument type.

*** Relative Paths
:PROPERTIES:
:CUSTOM_ID: relative-paths
:END:
A relative path specifies a location relative to the current working
directory, rather than from the root of the filesystem.

Your shell must correctly interpret and navigate the following
components of a relative path:

- =./= (Current Directory): Refers to the current working directory
  itself.
- =../= (Parent Directory): Refers to the directory immediately above
  the current working directory in the file system hierarchy.
- Subdirectories: Paths like =./dirname= or =dirname= are treated as
  relative to the current directory.

Here are some examples:

#+begin_src sh
$ pwd
/usr
$ cd ./local/bin    # Go to "local/bin" inside current directory (/usr)
$ pwd
/usr/local/bin
$ cd ../../         # Go up two levels
$ pwd
/usr
$ cd local          # "local" is shorthand for "./local"
$ pwd
/usr/local
#+end_src

*** Tests
:PROPERTIES:
:CUSTOM_ID: tests
:END:
The tester will execute your program like this:

#+begin_src sh
./your_program.sh
#+end_src

It will then send a series of =cd= commands to your shell:

#+begin_src sh
$ cd /usr
$ pwd
/usr
$ cd ./local/bin
$ pwd
/usr/local/bin
$ cd ../../
$ pwd
/usr
$
#+end_src

The tester will verify that: - Valid relative paths change the directory
correctly. - Invalid relative paths print the error message
=cd: <directory>: No such file or directory=. - The directory remains
unchanged when =cd= fails.

*** Notes
:PROPERTIES:
:CUSTOM_ID: notes
:END:
- The actual directory names used will be random, so you can't hardcode
  the expected output.
